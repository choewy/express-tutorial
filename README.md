# node-express-tutorial

본 프로젝트는 Node.js에서 express와 MongoDB를 사용하기 위한 튜토리얼이며, 이를 위해 간단한 Rest API 서버 및 Todo 앱을 구현하였다.

- [추후 heroku에서 server를 구동하여 배포할 예정]

## 의존성

```json
{
  "dependencies": {
    "body-parser": "^1.19.0",
    "dotenv": "^10.0.0",
    "ejs": "^3.1.6",
    "express": "^4.17.1",
    "express-session": "^1.17.2",
    "method-override": "^3.0.0",
    "mongodb": "^4.2.1",
    "multer": "^1.4.4",
    "nodemon": "^2.0.15",
    "passport": "^0.5.0",
    "passport-local": "^1.0.0"
  }
}
```

## 개요

Node.js는 브라우저가 아닌 환경에서도 JavaScript를 사용할 수 있는 환경을 제공해주는 JavaScript RunTime이다. 이는 Server 구현에도 많이 사용되며, Atom과 같은 Desktop Window 실행 프로그램을 개발하는 데에도 활용된다.

### Node.js

위에서 언급하였듯이 Node.js는 JavaScript RunTime이다. 따라서, `Node.js는 웹 서버이다.`라는 말로 한정짓기에는 그 범위가 매우 좁기도 하고, Node.js가 웹 서버의 역할을 수행하기 위해서는 HTTP 서버를 직접 구현하여야 한다.

> Apatch의 경우 html 파일 경로 지정, 서버 실행, PHP 실행, 세션 관리 등 서버를 운영하는데 필요한 기본 기능을 제공하는 반면, Node.js에는 이러한 기능이 전혀 없으므로 직접 구현해야 한다.

### Express

Express는 Node.js로 HTTP 서버를 구현하기 위한 웹 프레임워크이며, routing, session, template 등 웹 서버를 운영하는데 필요한 대부분의 기능이 구현되어 있다.

> routing은 애플리케이션 엔트 포인트(URI) 정의, URI가 클라이언트 요청에 응답하는 방식을 의미한다. Express에서는 주로 Router 객체를 별도로 분리하여 이를 모듈화하여 사용함으로써 유지보수 및 개발 시 효율성을 높일 수 있다.

## 서버 구현

express를 통해 서버를 구동하기 위한 코드는 아래와 같으며, 아래 코드는 express를 사용하기 위한 약속이기 때문에 왜 그런지 이해하기 보다는 외우는 편이 더 낫다.

```js
// server.js

const express = require('express');
const app = express();

const port = 8080;
app.listen(port, () => {
    console.log(`Node Todo App Server Running on port ${port}`);
});
```

의존성에서 nodemon을 설치하였으므로, 아래 명령어를 실행하면 서버를 구동시킬 수 있다.

```
$ nodemon server.js
```

서버를 구동하였음에도 불구하고 웹 브라우저를 통해 `http://localhost:8080`로 접속해보면 어떠한 웹 페이지도 보이지 않는다. 어떠한 웹 페이지 또는 정보를 조회하기 위해서는 웹 브라우저에서 서버로 GET 요청을 보내야 하는데, 현재 위의 코드에서는 GET 요청에 대한 코드가 없기 때문이다. 아래 코드를 추가하고 다시 접속해보면 웹 브라우저에 Hello World!가 출력될 것이다.

```js
// server.js

// ...(생략)

app.get('/', (req, res) => {
    res.send("Hello World!");
});
```

이번에는 텍스트가 아니라 html 파일을 응답으로 보내기 위해 아래와 같이 html 파일을 생성하도록 하자.

```html
<!-- public/index.html -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NODE TODO APP</title>
</head>
<body>
    NODE TODO APP | HOME PAGE
</body>
</html>
```

그리고, 서버로 GET 요청이 들어왔을 때의 코드를 아래 코드와 같이 수정하고, 다시 접속해보면, 위에서 작성한 웹 페이지를 확인할 수 있다.

```js
// server.js

// ...(생략)

app.get('/', (req, res) => {
    res.sendFile(__dirname + "/public/index.html");
});
```

## RESTful API

API(Application Programming Interface)는 프로그램 간 통신 규약이다. 이렇게 말하면 너무 어려우니, 조금 더 쉽게 설명하자면, 웹 서버와 클라이언트 간의 요청/응답 방식이라고 할 수 있다. 예를 들어, 현재 작성된 코드 중에서 `/` 라우팅 또한 일종의 API라고 할 수 있다. 개발자의 입장에서 좋은 API란 보기 쉽고, 관리하기 쉬운 API라고 할 수 있는데, 이와 같은 API를 RESTful API라고 한다. 기존에 API를 개발할 때에는 API에 일관성이 없을 뿐더러 구조 또한 정리되어 있지 않았기 때문에 이를 활용하는데 큰 번거로움이 있었다. 이를 해결하기 위해 `Roy Fielding`이라는 개발자가 http 요청에 대한 논문을 작성하였는데, 그것이 바로 REST(Representational State Transfer) 원칙이다. 이 논문이 유명해짐에 따라 현재는 RESTful API가 정론으로 받아들여지고 있다.

> REST 원칙으로 API를 개발하면 인터넷 세상이 평화로워짐 - Roy Fielding -

### REST 6 원칙

REST 원칙은 6개로 이루어져 있고, 개발자들 사이에서 이 모든 원칙을 잘 지켰을 때 '`RESTful` 하다.'라고 평가한다.

| 번호 | 원칙                       | 내용                                                         |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 1    | Uniform interface          | 간결하고 일관된 형식이어야 하며, 하나의 요청은 하나의 예측 가능한 URL로 매칭되어야 한다. 즉, URL에는 요청과 응답에 대한 충분한 정보가 포함되어야 한다. |
| 2    | Client와 Sever의 역할 구분 | 브라우저는 클라이언트 역할만 수행하여야 하고, 서버는 서버 역할만 수행하여야 한다. 즉, 브라우저는 요청만 하고, 서버는 응답만 하여야 한다. |
| 3    | Stateless                  | 각각의 요청은 서로 독립적이어야 한다. 즉, 서로 다른 요청에는 의존성이 없어야 한다. |
| 4    | Cacheable                  | 서버로부터 전달받은 정보는 캐싱이 가능해야 하고, 캐싱을 위한 버전 관리가 수행되어야 한다.(이 내용은 브라우저가 알아서 해결해주기 때문에 크게 신경쓰지 않아도 된다.) |
| 5    | Layered System             | 클라이언트는 서버에 직접 연결되었는지 또는 중간 서버를 통해 연결되었는지 알 수 없으므로, 아키텍처를 단순화하여 클라이언트와 서버 구조를 작은 단위로 분리시켜야 한다. |
| 6    | Code on Demand             | 서버는 JavaScript, Java Applet을 통해 클라이언트가 실행시킬 수 있는 로직을 전송하여 기능을 확장시킬 수 있어야 한다. |

위의 6가지 원칙 중에서 순위를 매긴다면 1번 원칙이 가장 중요하다고 할 수 있다. 그 이유는 1번 원칙을 지키는 경우 API 서버 개발자의 입장에서는 물론, API를 활용하는 다른 개발자들 입장에서 보았을 때에도 예측 가능하고, 잘 정리된 URL로 구성되어 있다면, 공식문서를 검색하는 시간을 줄여줌으로써 효율적인 개발이 가능하기 때문이다. 

예를 들어, RESTful API는 `/products/100/`, `/explore/tags/kpop/`과 같다. 첫 번째의 경우 해당 API를 통해 100번째 상품에 대한 정보를 받아볼 수 있다는 결과를 예측할 수 있다. 두 번째의 경우 태그들 중에서 kpop 태그에 대한 정보를 받아볼 수 있다는 결과를 예측할 수 있다. 이와 같이 간결하고, 형식이 갖추어져 있는 URL을 통해 그 결과를 충분히 예측할 수 있는 RESTful API를 개발하기 위해 노력해야 한다.

### URL 명명 규칙

RESTful API의 URL을 정하기 위해서는 몇 가지 규칙이 있는데, 이는 권장사항일 뿐이지 반드시 지켜야되는 부분은 아니다.

| 번호 | 규칙                   | 내용                                                         |
| ---- | ---------------------- | ------------------------------------------------------------ |
| 1    | 동사보다는 명사        | URL을 작성할 때에는 가급적이면 명사를 사용하도록 하자. 그 이유는 URL이 명사로 구성되어 있는 경우 어떠한 데이터를 요청하는지 파악하기 쉽기 때문이다. 예를 들어, 사용자의 정보를 요청하는 URL을 정할 때 `/getUser/:id`와 같이 동사가 아닌 `/users/:id`로 작성하면 훨씬 간결할 뿐더러 의미 또한 명확해진다. |
| 2    | 하위 경로는 `/`를 사용 | URL에서 하위 경로를 나타낼 때에는 `/`를 사용하도록 하자. 예를 들어, username이 choewy인 사용자의 사진을 조회하기 위해 POST로 요청하는 경우 body에 `{"username": "choewy"}`을 포함시킨 상태에서 `/images`로 요청할 수 있다. 그러나, 이 경우 페이지를 새로고침하면 요청 body에 대한 정보가 휘발되므로, `/images`로 GET 요청이 수행될 수도 있다. 따라서, `/images/choewy`으로 GET 요청을 한다면 훨씬 간결하고 예측 가능한 URL 주소로 활용될 수 있다. |

위에서 언급한 명명 규칙 외에도 `.html` 등 파일 확장자 미사용, 띄어쓰기 시 `-` 사용, 한 개의 자료는 하나의 URL로 표현 등 규칙이 있으나, 위의 2가지 규칙만 잘 지켜도 RESTful한 API를 작성할 수 있다. 

## MongoDB

먼저, 데이터베이스에는 크게 관계형 데이터베이스인 RDBMS와 NoSQL로 구분된다. MongoDB는 NoSQL 데이터베이스 중 단연 1위를 차지하고 있는 데이터베이스이다. 

### NoSQL을 사용하는 이유

RDBMS에는 MySQL, OracleDB, MsSQL 등이 있다. RDBMS는 열과 행으로 구성되어 있기 때문에 엑셀과 같이 2차원 데이터를 다루기 편리하다는 장점이 있으나, 3차원 데이터는 다루기 어렵다는 단점이 있다. 

> 3차원 데이터라 함은 여러 테이블의 정보가 또 다른 테이블 안에 포함된 형태라고 할 수 있다. 예를 들어, 사용자의 정보가 담긴 테이블에 사용자가 게시한 글의 정보가 포함되어 있는 구조라고 할 수 있다. 

RDBMS에서 3차원 데이터를 구현하기 위해서는 JOIN으로 구현하지만, NoSQL는 JSON 파일 형태로 구성되어 있으므로 보다 쉽게 3차원 데이터를 관리할 수 있다.

```json
{
    "username": "",
    "articles": [
        {
            "id": 1,
            "title": "",
            "content": ""
        }
        {
            "id": 2,
            "title": "",
            "content": ""
        }
    ],
    "password": ""
}
```

MongoDB를 사용하기 위해서는 로컬에 직접 설치하기도 하지만, MongoDB Atlas를 통해 512MB 용량의 데이터베이스를 무료로 사용해볼 수 있다.

## 사용자 인증

사용자 인증 기능을 구현하기 위해 사용되는 기술에는 크게 Session, JWT, OAuth가 있다. 

### Session

어떠한 사용자가 로그인을 했을 때 서버는 쿠키를 발행한다. 

> 여기서 쿠키란, 문자열 형태로 브라우저에 저장할 수 있는 공간이다. 이 쿠키에는 사용자의 세션 ID가 기록되어 있고, 서버는 세션 ID를 서버 메모리 또는 DB에 저장한 다음에 인증 결과를 쿠키에 담아서 다시 사용자에게 보내준다.

이렇게 인증에 성공한 사용자는 서버에게 어떠한 페이지를 요청할 때마다 쿠키에 세션 ID를 담아 서버에게 전송하고, 서버는 서버 메모리 또는 세션 DB에서 사용자가 보낸 세션 ID를 조회하여 유효성 검사를 수행한 후 그 결과에 따라 사용자가 요청한 페이지를 보내주거나, 해당 페이지에 대한 접속을 차단할 수 있다.

### JWT

JWT(Json Web Token)는 사용자가 아이디, 비밀번호와 같은 인증 정보를 서버에게 전송하고, 서버는 이 정보를 통해 유효성 검사를 수행한 후 인증이 성공하면 웹 토큰을 사용자에게 전송하는 방식이다. 여기에 사용되는 웹 토큰은 JSON 형식에 담긴 정보를 암호화한 긴 문자열이다. 인증에 성공한 사용자는 서버로부터 받은 웹 토큰을 웹 브라우저 로컬 스토리지 또는 쿠키에 저장하여, 서버에게 페이지를 요청하거나 기타 작업을 할 때마다 해당 토큰을 함께 전송한다. 서버는 사용자로부터 받은 토큰의 유효성을 검사하고, 그 결과에 따른 응답을 사용자에게 전송한다. 

> JWT는 사용자들의 인증 정보를 서버 메모리 또는 별도의 DB에 저장할 필요가 없으므로, Session 방식보다는 RESTful 하다.

### OAuth

OAuth(Open Authentication)은 최근 많은 웹 서비스에서 활용하고 있는 방식으로 다른 서비스의 프로필 정보를 활용하는 방식이다. 예를 들어, 어떠한 쇼핑몰에 로그인할 때 구글 계정을 통한 회원가입 또는 로그인하는 경우를 볼 수 있는데, 이 경우가 바로 OAuth를 활용한 인증 처리이다. 이는 단순히 사용자 정보를 다른 웹 서비스에서 가져오는 것에 불과하므로, 사용자 인증 결과를 유지하기 위해서는 별도의 session 또는 JWT 방식을 적용하여야 하는 번거로움이 있으나, 사용자의 정보를 다른 웹 서비스로부터 불러옴으로써 별도의 보안 처리는 하지 않아도 된다는 장점이 있다.

## 보안

웹 사이트를 배포하여 운영할 때 가장 중요시 되는 부분 중 하나가 바로 보안이다. 보안의 범위는 굉장히 넓지만, 극히 단순한 부분의 보안을 다루고자 한다. 

> 서버를 운영할 때에는 서버 공격, 데이터베이스 유출 등에 대한 대비가 반드시 마련되어야 한다.

보안의 범위를 알기 위해서는 먼저 자기 자신이 악성유저가 되어보는 것이다. 즉, 자신이 개발한 웹 사이트에 직접 접속해서 이것저것 다양한 시도를 해보는 것이다. 예를 들어, 회원가입 시 아이디를 한글로 작성해서 요청하거나, 로그인하지 않은 상태에서 URL을 통해 데이터 조작을 시도하는 등 여러 시도를 해보는 것이다. 

### XSS 공격

XSS 공격이란, `input` 태그 또는 `textarea` 태그에 실제 JavaScript 코드를 입력하여, 서버로 전송하는 기법의 공격이다. 이렇게 서버로 전송된 JavaScript 코드는 데이터베이스에 저장되는데, 데이터베이스에서 해당 코드를 불러올 때 이 코드가 실행되어 예기치 못한 오류가 발생하거나, 데이터가 유출되는 등의 문제가 발생할 수 있다. XSS 공격을 대비하기 위해서는 `<`, `>` 기호가 입력되지 못하도록 설정하거나, 해당 기호들을 각각 `&lt;`, `&gt;`로 변경하여 서버 내에서의 외부 코드 실행을 방지할 수 있다. 

### Brute force 공격

Brute force 공격은 짧은 시간에 사용자의 비밀번호를 알아내기 위한 공격이다. 예를 들어, 1분 동안 다양한 비밀번호로 약 1억 번의 로그인 요청을 하여 비밀번호를 알아내는 경우가 Brute force라고 할 수 있다. 이를 방지하기 위해서는 `Captcha`를 도입하거나, `express-rate-limit` 라이브러리를 사용하여 요청 횟수를 제한할 수 있다.

### 비밀번호 유출

웹 서비스 이용자들은 여러 웹 서비스 계정을 동일한 비밀번호로 이용하는 경우가 많다. 다양한 웹 서비스 중에서 웹 서비스 하나의 데이터베이스 정보가 유출되는 경우 해커는 여러 사이트에 해당 계정으로 접근을 시도할 수 있다. 이를 방지하기 위해서는 웹 서비스 계정마다 서로 다른 아이디 또는 비밀번호를 사용하는 것이 바람직하다.

## 실시간 통신

채팅과 같이 데이터베이스와 실시간으로 통신할 수 있는 기능을 구현하는데에는 크게 두 가지 방법이 있다.

### setTimeOut

첫 번째 방법으로는 `setTimeOut()`을 사용하여 1초마다 GET 요청을 할 수 있다. 그러나, 이 방법을 사용하는 경우에는 큰 위험이 존재한다. 예를 들어, 사용자가 1 ~ 2명인 경우는 크게 상관이 없겠으나, 사용자의 수가 늘어남에 따라 요청 처리 수가 기하급수적으로 늘어나기 때문에 초고사양의 CPU가 탑재된 서버가 아닌 이상 서버에 큰 부하가 발생한다. 

> 이와 같이 짧은 시간 안에 방대한 요청을 한꺼번에 보내는 것을 DDoS 공격이라고 하는데, 해당 방법을 사용하는 경우에는 DDoS를 서버에 적용한다고 해도 과언이 아닐 것이다.

### Server Sent Events

두 번째 방법으로는 서버와 클라이언트 간에 실시간 통신 채널을 개방하는 것인데, 이를 Server Sent Events라고 한다. 이와 같이 실시간 통신 채널을 개방하면, 서버는 클라이언트에게 일방적으로 실시간 데이터를 전송한다. 즉, 사용자는 별도의 GET 요청 없이도 실시간 데이터를 받아볼 수 있는 것이다. 클라이언트가 http 요청(GET, POST)을 통해 서버와 통신할 때, 사용자가 사용하는 언어, 브라우저의 정보, 쿠키 데이터, 출처 등과 같은 데이터를 Header에 포함시켜 서버에게 전달하고, 서버 또한 이와 같은 정보를 Header에 담아 클라이언트에게 전송하는데, Header에는 http 요청 시 기본적으로 요청과 응답의 수가 같도록(1회 요청 시 1회 응답) 설정되어 있다. 

실시간 통신 채널을 개방하기 위해서는 서버가 클라이언트에게 응답할 때 보내는 Header를 아래와 같이 변경하면 된다.

```js
app.get(URL, middleware, (req, res) => {
    res.writeHead(200, {
        "Connection": "keep-alive",
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache"
    });
})
```

Header 설정을 마치고, 데이터를 클라이언트에게 전달할 때에는 아래 코드와 같이 이벤트명을 `event: [이벤트명]\n`에, 전송하고자 하는 데이터를 `data: [데이터]\n\n`로 하여 `write()` 함수에 담아 전송하여야 한다.

```js
    res.write('event: event_name\n');
    res.wreite('data: data\n\n');
```

반대로, 서버가 보낸 실시간 데이터를 클라이언트에서 받기 위해서는 아래 코드와 같이 `EventSource()` 함수에 GET 요청을 하기 위한 URL을 파라미터로 담아서 새로운 객체를 생성하고, 해당 객체에 이벤트 리스너를 연결하여 콜백 함수를 통해 실시간 데이터를 받아볼 수 있다.

```html
<script>
    const eventSource = new EventSource(URL);
    eventSource.addEventListner('이벤트명', (event) => {
        console.log(event.data);
    });
</script>
```

